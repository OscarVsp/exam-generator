from typing import List, Dict
import __main__
import subprocess
import os, sys
import random
import csv
import yaml

# TODO Cleaner

from .questions_set.base_question_set import BaseQuestionsSet
from .questions_set.short_question import ShortQuestionsSet
from .questions_set.large_question import LargeQuestionsSet


class Generator:
    """
    The `Generator` class handle the overall parameter of the exam, such as:

    - `course_name`
    - `course_code`
    - `year`
    - `session`

    When `generate_from_csv` is called, it load the `students_list.csv` (can be overide) to get the list of students, then generate the pdf of the exam for each one of them.

    The `students_list.csv` can be directly edited or you can convert existing `xlsx` file.

    """

    _MAIN_PREFIX = "%This file is automatically generated. DO NOT EDIT!\n\n\\documentclass[a4paper,11pt]{article}\n\\usepackage{preamble}\n\\begin{document}"

    _MAIN_POSTFIX = "\\end{document}"

    def __init__(
        self,
        course_name: str,
        course_code: str,
        year: str,
        session: str,
        reset_page_counter: bool = False,
        output_dir: str = None,
    ) -> None:
        self.course_name = course_name
        self.course_code = course_code
        self.year = year
        self.session = session
        self.reset_page_counter = reset_page_counter
        self.output_dir = (
            f"{os.getcwd()}/{output_dir}"
            if output_dir
            else f"{os.path.dirname(__main__.__file__)}/exam_files"
        )
        if not os.path.exists(self.output_dir):
            print(f"Directory does not exist. Creating: {self.output_dir}")
            os.makedirs(self.output_dir)

        self.questions_sets: List[BaseQuestionsSet] = []
        self.main_content: str = ""
        self.latex_path: str = os.path.dirname(__file__) + "/latex"
        if not os.path.exists(self.latex_path + "/tmp"):
            os.makedirs(self.latex_path + "/tmp")

        self._clear_tmp()

        self._generate_header()

    @classmethod
    def gen_from_config(cls, filename: str) -> "Generator":
        with open(filename, "r") as file:
            config = yaml.safe_load(file)
            gen = Generator(
                config["exam"]["name"],
                config["exam"]["code"],
                config["exam"]["year"],
                config["exam"]["session"],
                config["reset_page_counter"],
                config["output_dir"],
            )
            for set_config_item in config["sets"]:
                set_type = list(set_config_item.keys())[0]  # FIXME not safe
                set_config = set_config_item[set_type]
                if set_type.lower() == "short":
                    new_set = ShortQuestionsSet(
                        set_config["name"],
                        set_config["path"],
                        set_config["size"],
                        set_config["consigne"],
                        set_config["blank_line"],
                    )
                elif set_type.lower() == "large":
                    new_set = LargeQuestionsSet(
                        set_config["name"],
                        set_config["path"],
                        set_config["size"],
                        set_config["consigne"],
                        set_config["blank_page"],
                    )
                else:
                    raise ValueError(
                        f'Error loading the config from file. Set type "{set_type}" is not valid.'
                    )
                gen.add_set(new_set)
            gen.generate_from_csv(config["csv_path"])

    def _generate_header(self) -> None:
        """
        Generate the `header.sty` file to pass the exam data to latex.

        This is called once at initialisation.
        """
        latex_content = "%This file is automatically generated. DO NOT EDIT!\n\n"
        latex_content += r"\newcommand{\academicyear}{" + self.year + "}\n"
        latex_content += r"\newcommand{\session}{" + self.session + "}\n"
        latex_content += r"\newcommand{\coursename}{" + self.course_name + "}\n"
        latex_content += r"\newcommand{\coursecode}{" + self.course_code + "}"
        with open(
            self.latex_path + "/tmp/header.sty", mode="w", encoding="UTF-8"
        ) as fp:
            fp.write(latex_content)

    def _generate_main(self) -> None:
        """
        Generate the `main.tex` file containing references to the differents part of the exam.

        This is called at once the begining of the generate process.
        """
        print(f"Latex file initialization...")
        latex_content = self._MAIN_PREFIX
        for index, questions_set in enumerate(self.questions_sets):
            latex_content += f"\n\\begin{{center}}\n{{\\Large \\textbf{{Part {index+1} - {questions_set.name}}}}}\n\\end{{center}}\n"
            latex_content += (
                f"\\lfoot{{Part {index+1} - {questions_set.name}}}\n\\smallskip\n"
            )
            latex_content += (
                f"\\input{{tmp/{questions_set.name.lower()}_set.tex}}\n\\newpage\n"
            )
            if self.reset_page_counter:
                latex_content += f"\\setcounter{{page}}{{1}}\n"
        latex_content += self._MAIN_POSTFIX
        with open(self.latex_path + "/main.tex", mode="w", encoding="UTF-8") as fp:
            fp.write(latex_content)

    def _generate_student_sty(self, name: str, matricule: int = None) -> None:
        with open(
            self.latex_path + "/tmp/student_name.sty", mode="w", encoding="UTF-8"
        ) as fp:
            fp.write(f"%This file is automatically generated. DO NOT EDIT!")
            fp.write(f"\\newcommand{{\\name}}{{{name}}}")
            if matricule is not None:
                fp.write(f"\\newcommand{{\\matricule}}{{\\\\ {matricule}}}")
            else:
                fp.write(f"\\newcommand{{\\matricule}}{{}}")

    def _generate_pdf(self, name: str) -> None:
        """
        This passes the current student name to latex, them uses the `MakeFile` to build the pdf file.
        The file is finally renamed and moved into the exam folder.

        This is call at the end of each files generation

        Args:
            name (str, optional): name of the student.
        """
        process = subprocess.run(
            ["make", "-C", self.latex_path], stdout=subprocess.DEVNULL, timeout=60
        )
        if process.returncode != 0:
            raise Exception(
                f"Fail to generate pdf. Make return code: {process.returncode}. Check if Latex is installed."
            )
        os.rename(
            self.latex_path + "/output-files/main.pdf",
            f"{self.output_dir}/{name.replace(' ','_')}_{self.course_code}_EXAM_{self.year}_{self.session}.pdf",
        )

    def _generate_set(self, name: str, matricule: int = None) -> None:
        """
        This fix the random seed from the student matricule or fullname, then call the generation method of each question set.

        Args:
            name (str): name of the student
            matricule (int): Matricule of the student
        """
        if matricule is None:
            matricule = "".join(map(str, map(ord, name)))
        random.seed(matricule)

        for questions_set in self.questions_sets:
            questions_set.generate(self.latex_path)

    def add_set(self, new_set: BaseQuestionsSet) -> None:
        """
        Register the provided QuestionSet to be used for the exam.

        Args:
            new_set (BaseQuestionsSet): The question set to be added.
        """
        self.questions_sets.append(new_set)

    def _generate_student(
        self, student_name: str, student_matricule: int = None
    ) -> None:
        """
        Internal method to generate exam file for a single student.

        Used by "generate_single", "generate_from_dict" and "generate_from_csv".

        Args:
            student_name (str): full name of the student
            student_matricule (int, optional): matricule of the student
        """
        print(f"Genering pdf for {student_name}:{student_matricule}...")
        self._clear_tmp()
        self._generate_student_sty(student_name, student_matricule)
        self._generate_set(student_name, student_matricule)
        self._generate_pdf(student_name)

    def generate_single(self, student_name: str, student_matricule: int = None) -> None:
        """
        Generate exam file for a single student.

        For multiple student, please use `generate_from_dict` or `generate_from_csv` instead.

        Args:
            student_name (str): full name of the student
            student_matricule (int, optional): matricule of the student
        """
        self._generate_main()
        self._generate_student(student_name, student_matricule)
        print("Finished")

    def generate_from_dict(self, students_dict: Dict[str, int | None]) -> None:
        """
        Generate exam file for a dict of student with the following structure: `{name:matricule}`.

        Args:
            students_dict (dict): The dict of `{name:matricule}` pairs".
        """

        self._generate_main()
        for name, matricule in students_dict.items():
            self._generate_student(name, matricule)
        print("Finished")

    def generate_from_csv(
        self, filename: str = os.path.dirname(__main__.__file__) + "/students_list.csv"
    ) -> None:
        """
        Generate exam file for a list of student provided in a `.csv` file.

        Args:
            filename (str, optional): The filename of the `.csv` file. Defaults to "students_list.csv".
        """
        print(f"Loading student list from csv file...")
        students_dict = Generator._csv_to_dict(filename)
        self.generate_from_dict(students_dict)

    def _clear_tmp(self) -> None:

        subprocess.run(
            ["make", "-C", self.latex_path, "clean"],
            check=False,
            stdout=subprocess.DEVNULL,
        )
        tmp_files = [
            os.path.join(self.latex_path + "/tmp", f)
            for f in os.listdir(self.latex_path + "/tmp")
            if f != "header.sty"
        ]
        for f in tmp_files:
            try:
                os.remove(f)
            except (FileNotFoundError, PermissionError, IsADirectoryError):
                pass

    @staticmethod
    def _csv_to_dict(
        filename: str = os.path.dirname(__main__.__file__) + "/students_list.csv",
    ) -> Dict[str, int | None]:
        students = {}

        with open(filename, mode="r", encoding="UTF-8") as fp:
            students_csv = csv.DictReader(fp)

            for student_row in students_csv:
                students[
                    student_row[students_csv.fieldnames[0]].strip().upper()
                    + " "
                    + student_row[students_csv.fieldnames[1]].strip()
                ] = (
                    int(student_row[students_csv.fieldnames[2]].strip())
                    if student_row[students_csv.fieldnames[2]].strip() != ""
                    else None
                )
        return students
